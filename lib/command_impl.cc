/* -*- c++ -*- */
/* 
 * Copyright 2016 <+YOU OR YOUR COMPANY+>.
 * 
 * This is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 * 
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <gnuradio/io_signature.h>
#include "command_impl.h"

#include <sys/types.h>
#include <sys/wait.h>

//#define DBG(f, x...) {fprintf(stderr,"[%s() %d %p]: " f, __func__, __LINE__ ,this, ##x); fflush(stderr);}
//#define DBG(f, x...) {fprintf(stdout,"[%s() %d %p]: " f, __func__, __LINE__ ,this, ##x); fflush(stdout);}
#define DBG(f, x...)

namespace gr {
  namespace command_block {

    enum { TYPE_IN=1, TYPE_OUT=2 };
    enum { BLOCKING_NONE=0, BLOCKING_IN=1, BLOCKING_OUT=2 };//BLOCKING_both = BLOCKING_IN | BLOCKING_OUT == 3

    command::sptr
    command::make(size_t in_item_size, size_t out_item_size, const char* cmd, double io_ratio, int blocking)
    {
      return gnuradio::get_initial_sptr
        (new command_impl(in_item_size, out_item_size, cmd, io_ratio, blocking));
    }

    /*
     * The private constructor
     */
    command_impl::command_impl(size_t in_item_size, size_t out_item_size, const char* cmd, double io_ratio, int blocking)
      : gr::block("command",
              gr::io_signature::make(0, (in_item_size > 0)?1:0, in_item_size),
              gr::io_signature::make(0, (out_item_size > 0)?1:0, out_item_size)),
          cmd(cmd),io_ratio(io_ratio),in_item_size(in_item_size),out_item_size(out_item_size),blocking(blocking)
    {
        type = 0;
        if(in_item_size > 0)type |= TYPE_IN;
        if(out_item_size > 0)type |= TYPE_OUT;
        DBG("in %d out %d cmd \"%s\"\n",(type & TYPE_IN),(type & TYPE_OUT)>>1, cmd);
        DBG("blocking in %d out %d\n",blocking & BLOCKING_IN, (blocking & BLOCKING_OUT)>>1);
    }

    /*
     * Our virtual destructor.
     */
    command_impl::~command_impl()
    {
    }

    bool command_impl::start(){
      if(pipe(stdin_pipe) != 0){
        throw errno_exception("pipe()", errno);
      }

      if(pipe(stdout_pipe) != 0){
        throw errno_exception("pipe()", errno);
      }

      pid = fork();
      if (pid == -1) {
        return false;
      }
      else if (pid == 0) {

        if(type & TYPE_IN){
          dup2(stdin_pipe[0], STDIN_FILENO);
          close(stdin_pipe[0]);
          close(stdin_pipe[1]);
        }

        if(type & TYPE_OUT){
          dup2(stdout_pipe[1], STDOUT_FILENO);
          close(stdout_pipe[1]);
          close(stdout_pipe[0]);
        }
        
        execl("/bin/sh", "sh", "-c", cmd, NULL);

        exit(EXIT_FAILURE);
      }
      else {

        if(type & TYPE_IN){

          close(stdin_pipe[0]);
          if(blocking & BLOCKING_IN)unset_fd_flags(stdin_pipe[1], O_NONBLOCK);
          else set_fd_flags(stdin_pipe[1], O_NONBLOCK);
          fcntl(stdin_pipe[1], F_SETFD, FD_CLOEXEC);

          cmd_in = fdopen(stdin_pipe[1], "w");
          if (cmd_in == NULL) {
            throw errno_exception("fdopen()", errno);
          }

        }

        if(type & TYPE_OUT){
          if(blocking & BLOCKING_OUT)unset_fd_flags(stdout_pipe[0], O_NONBLOCK);
          else set_fd_flags(stdout_pipe[0], O_NONBLOCK);
          fcntl(stdout_pipe[0], F_SETFD, FD_CLOEXEC);
          close(stdout_pipe[1]);

          cmd_out = fdopen(stdout_pipe[0], "r");
          if (cmd_out == NULL) {
            throw errno_exception("fdopen()", errno);
          }
        }
      }

      return true;
    }   

    bool command_impl::stop(){
      pid_t rc;
      char buf[PIPE_BUF];
      ssize_t sz;
      int i;
      int pstat;

      // Set file descriptors to blocking, to be sure to consume
      // the remaining output generated by the process.
      unset_fd_flags(stdin_pipe[1], O_NONBLOCK);
      unset_fd_flags(stdout_pipe[0], O_NONBLOCK);

      if(type & TYPE_IN)fclose(cmd_in);

      if(type & TYPE_OUT){
        i = 0;
        do {
          sz = read(stdout_pipe[0], buf, sizeof (buf));
          if (sz < 0) {
            break ;
          }
          i++;
        } while (i < 256 && sz > 0);
        fclose(cmd_out);
      }

      do {
        rc = waitpid(pid, &pstat, 0);
      } while (rc == -1 && errno == EINTR);

      if (rc == -1) {
        return true;
      }

      if (WIFEXITED(pstat))
        std::cerr << "Process exited with code " << WEXITSTATUS(pstat) << std::endl;
      else
        std::cerr << "Abnormal process termination" << std::endl;

      return true;
    }

    void
    command_impl::forecast (int noutput_items, gr_vector_int &ninput_items_required)
    {
        ninput_items_required[0] = noutput_items / io_ratio;
    }

    int
    command_impl::general_work (int noutput_items,
                       gr_vector_int &ninput_items,
                       gr_vector_const_void_star &input_items,
                       gr_vector_void_star &output_items)
    {
      int produced = 0;
      int consumed = 0;

      if(type & TYPE_IN){
        const void *in = (const void *) input_items[0];
        consumed = fwrite(in,in_item_size,ninput_items[0],cmd_in);
        if(consumed == 0 && ferror(cmd_in) && errno != EAGAIN && errno != EWOULDBLOCK){
          throw errno_exception("fwrite()", errno);
        }
        consume_each(consumed);
        if(blocking > BLOCKING_NONE)fflush(cmd_in);
      }

      if(type & TYPE_OUT){
        void *out = (void *) output_items[0];
        produced = fread(out,out_item_size,noutput_items,cmd_out);
        if(produced == 0 && ferror(cmd_out) && errno != EAGAIN && errno != EWOULDBLOCK){
          throw errno_exception("fread()", errno);
        }
        if(produced == 0 && feof(cmd_out))produced = -1;
      }


      // Tell runtime system how many output items we produced.
      return produced;
    }

    void command_impl::set_fd_flags(int fd, int flags)
    {
      int rc;

      rc = fcntl(fd, F_GETFL);
      if (rc == -1) {
        throw errno_exception("fcntl()", errno);
      }

      rc = fcntl(fd, F_SETFL, rc | flags);
      if (rc == -1) {
        throw errno_exception("fcntl()", errno);
      }
    }

    void command_impl::unset_fd_flags(int fd, int flags)
    {
      int rc;

      rc = fcntl(fd, F_GETFL);
      if (rc == -1) {
        throw errno_exception("fcntl()", errno);
      }

      rc = fcntl(fd, F_SETFL, rc & ~flags);
      if (rc == -1) {
        throw errno_exception("fcntl()",errno);
      }
    }

    //FIXME std::system_error may be better for this
    std::runtime_error command_impl::errno_exception(const char * msg, int err){
      std::stringstream s;
      s << msg << " " << strerror(err) << std::endl;
      return std::runtime_error(s.str());
    }


  } /* namespace command_block */
} /* namespace gr */

